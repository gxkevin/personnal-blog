<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、获取数据 | 李斌 Blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.235e9f47.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.c767e7d4.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.2d10be97.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/16.474d60b7.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.56d88f95.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.c6178770.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.701ab363.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.8d0b9623.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.9c3f78d8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.460d7e6c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.2bc2ec19.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.a32be7da.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.c73eb15d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.bed14e33.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.82d52ce4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.d10b5a58.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.7c7c5ad1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.2e43e933.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.9ec803b1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.7d5f245c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.a4522073.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.b1e57bd3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.22bd9833.js"><link rel="prefetch" href="/vuepress-blog/assets/js/8.e9e3ce9b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/9.73b9c7be.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.235e9f47.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">李斌 Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/vuepress-blog/web/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="https://github.com/LiMiu331" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee/limiu331/readbook.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  读书笔记
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/vuepress-blog/web/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="https://github.com/LiMiu331" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee/limiu331/readbook.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  读书笔记
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>一、获取数据</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/web/js-ajax.html#一、获取数据" class="sidebar-link">一、获取数据</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vuepress-blog/web/js-ajax.html#二、ajax技术的核心-xmlhttprequest对象" class="sidebar-link">二、AJAX技术的核心 - XMLHttpRequest对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/web/js-ajax.html#方法" class="sidebar-link">方法</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/web/js-ajax.html#属性" class="sidebar-link">属性</a></li></ul></li><li><a href="/vuepress-blog/web/js-ajax.html#三、准备ajax请求" class="sidebar-link">三、准备AJAX请求</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/web/js-ajax.html#（一）get请求-与-post请求" class="sidebar-link">（一）GET请求 与 POST请求</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/web/js-ajax.html#（二）请求url地址" class="sidebar-link">（二）请求URL地址</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/web/js-ajax.html#（三）同步请求与异步请求" class="sidebar-link">（三）同步请求与异步请求</a></li></ul></li><li><a href="/vuepress-blog/web/js-ajax.html#四、设置请求头" class="sidebar-link">四、设置请求头</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vuepress-blog/web/js-ajax.html#五、发送请求" class="sidebar-link">五、发送请求</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vuepress-blog/web/js-ajax.html#六、处理响应" class="sidebar-link">六、处理响应</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vuepress-blog/web/js-ajax.html#七、取消异步请求" class="sidebar-link">七、取消异步请求</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="一、获取数据"><a href="#一、获取数据" class="header-anchor">#</a> 一、获取数据</h2> <p>我们知道AJAX用来在项目中以阻止页面刷新的方式获取数据，那么数据从哪里来呢？我们又怎么知道如何获取这些数据？答案是我们通常使用<strong>API</strong>与各式各样的数据库交互。</p> <p>“API”是“Application Programming Interface”(即：应用程序接口)的缩写，你可以想象一些数据是开放的并且在等待被使用，而我们获取这些数据的方式便是使用API。API通常的形式是一个URL，并提供指定的参数名和参数值用来帮助你定位所要获取的数据。</p> <p>还记得我们提过AJAX需要服务器端的相应设置吗？我们之后会再来谈这一点。</p> <hr> <h2 id="二、ajax技术的核心-xmlhttprequest对象"><a href="#二、ajax技术的核心-xmlhttprequest对象" class="header-anchor">#</a> 二、AJAX技术的核心 - XMLHttpRequest对象</h2> <p>让我们先把服务器端的设置抛在一边，聚焦AJAX技术的核心环节：<code>XMLHttpRequest</code>对象。</p> <p><code>XMLHttpRequest</code>对象是浏览器提供的一个API，用来顺畅地向服务器发送请求并解析服务器响应，当然整个过程中，浏览器页面不会被刷新。它将是本文接下来的主角，让我们先站在较高的层次，对该对象有一个全局的概览：</p> <ol><li><code>XMLHttpRequest</code>只是一个JavaScript对象，确切的说，是一个<strong>构造函数</strong>。换句话说，它一点也不神秘，它的特殊之处只在于它是由客户端(即浏览器)提供的（而不是JavaScript原生的），除此之外，它有属性，有方法，需要通过<code>new</code>关键字进行实例化，我们只需掌握它们就好；</li> <li><code>XMLHttpRequest</code>对象是不断被扩展的。随着XML对象被广泛的接收，W3C也开始着手制定相应的标准来规范其行为。目前，<code>XMLHttpRequest</code>有两个级别：1级提供了XML对象的实现细节，2级进一步发展了XML对象，额外添加了一些方法，属性和数据类型。但是，并不是所有浏览器都实现了XML对象2级的内容（并不意外，对吧？）；</li></ol> <p>让我们先从剖析<code>XMLHttpRequest</code>实例的属性和方法开始，先创建一个XML对象的实例：</p> <div class="language- extra-class"><pre class="language-text"><code>const xhr = new XMLHttpRequest()
复制代码
</code></pre></div><p>该实例的属性，方法有：</p> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <ul><li><code>.open()</code>：准备启动一个AJAX请求；</li> <li><code>.setRequestHeader()</code>：设置请求头部信息；</li> <li><code>.send()</code>：发送AJAX请求；</li> <li><code>.getResponseHeader()</code>: 获得响应头部信息；</li> <li><code>.getAllResponseHeader()</code>：获得一个包含所有头部信息的长字符串；</li> <li><code>.abort()</code>：取消异步请求；</li></ul> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <ul><li><code>.responseText</code>：包含响应主体返回文本；</li> <li><code>.responseXML</code>：如果响应的内容类型时<code>text/xml</code>或<code>application/xml</code>，该属性将保存包含着相应数据的XML DOM文档；</li> <li><code>.status</code>：响应的HTTP状态；</li> <li><code>.statusText</code>：HTTP状态的说明；</li> <li><code>.readyState</code>：表示“请求”/“响应”过程的当前活动阶段</li></ul> <p>另外，浏览器还为该对象提供了一个<code>onreadystatechange</code>监听事件，每当XML实例的<code>readyState</code>属性变化时，就会触发该事件的发生。</p> <p>至此，关于XMLHttpRequest实例对象的属性方法就全部罗列完毕了，接下来，我们将更进一步的探究如何使用这些方法，属性完成发送AJAX请求的流程。</p> <hr> <h2 id="三、准备ajax请求"><a href="#三、准备ajax请求" class="header-anchor">#</a> 三、准备AJAX请求</h2> <p>要想与服务器交互，我们首先需要回答以下问题：</p> <ul><li>我们是要获取数据还是存储数据？  --表现为请求方式的不同：<code>GET</code>或<code>POST</code>；</li> <li>向哪里发出请求？  --即相应API地址；</li> <li>以何种方式等待响应？  --有“<strong>同步</strong>”和“<strong>异步</strong>”两种选择；（网络传输是一个过程，请求和响应不是同时发生的。）</li></ul> <p>而XMLHttpRequest实例的<code>.open()</code>方法的作用就是用来回答以上三个问题。<code>.open()</code>方法接收三个参数：<strong>请求方式</strong>，<strong>请求URL地址</strong>和<strong>是否为异步请求的布尔值</strong>。</p> <p>下面是一个<code>.open()</code>方法调用的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>// 该段代码会启动一个针对“example.php”的GET同步请求。
xhr.open(&quot;get&quot;, &quot;example.php&quot;, false)
复制代码
</code></pre></div><p>相当于开始做饭前，将工具准备齐备，将菜洗好，<code>.open()</code>方法也同样出色地完成了发送AJAX请求的准备工作。</p> <p>现在，让我们再深入聊聊一些准备工作的细节：</p> <h3 id="（一）get请求-与-post请求"><a href="#（一）get请求-与-post请求" class="header-anchor">#</a> （一）GET请求 与 POST请求</h3> <ul><li>GET请求</li></ul> <p>GET请求用于<strong>获取数据</strong>，有时候我们需要获取的数据需要通过“查询参数”进行定位，在这种情况下，我们会将查询参数追加到URL的末尾，令服务器解析。</p> <p>查询参数是指一个由<code>?</code>号起始，由<code>&amp;</code>符号分割的包含相应键值对的字符串。用来告知浏览器所要查询的特定资源。</p> <div class="language- extra-class"><pre class="language-text"><code>const query = &quot;example.php?name=tom&amp;age=24&quot; // &quot;?name=tom&amp;age=24&quot;即是一个查询参数
复制代码
</code></pre></div><p>需要注意的是，查询字符串中每个参数的名和值都必须使用encodeURIComponent()进行编码（这是因为URL中有些字符会引起歧义，例如“&amp;”）。</p> <ul><li>POST请求</li></ul> <p>POST请求用于<strong>向服务器发送应该被保存的数据</strong>，因此POST请求天然比GET请求多需要一份<strong>需要被保存的数据</strong>。那么这些数据应该放在何处呢？毕竟，我们的<code>.open()</code>方法接收的三个参数都没有合适的位置。</p> <p>答案是需要发送的数据会作为<code>.send()</code>方法的参数最终被发往服务器，该数据可以是任意大小，任意类型。</p> <p>这里需要注意以下两点：</p> <ol><li><code>.send()</code>方法的参数是不可为空的，也就是说，对于不需要发送任何数据的GET请求，也需要在调用<code>.send()</code>方法时，向其传入<code>null</code>值；</li> <li>目前为止，我们知道了两种向服务器发送数据的方式：<strong>表单提交</strong>以及<strong>发送POST请求</strong>，要注意服务器对待这两种方式并不一视同仁，这意味着服务器需要有相应的代码专门处理POST请求发送来的原始数据。</li></ol> <p>但好在我们可以通过POST请求模拟表单提交，只需要简单两步：</p> <ol><li>设置请求头参数：<code>Content-Type: application/x-www-form-urlencoded</code>（表单提交时的内容类型）；</li> <li>将表单数据序列化为查询字符串形式，传入<code>.send()</code>方法；</li></ol> <h3 id="（二）请求url地址"><a href="#（二）请求url地址" class="header-anchor">#</a> （二）请求URL地址</h3> <p>这里需要注意若使用相对路径，请求URL是<strong>相对于执行代码的当前页面</strong>。</p> <h3 id="（三）同步请求与异步请求"><a href="#（三）同步请求与异步请求" class="header-anchor">#</a> （三）同步请求与异步请求</h3> <p>人们通常认为AJAX是异步的，实际上并非如此，AJAX是避免页面在获取数据后刷新的一种技术，至于等待服务器响应的方式是同步还是异步，需要开发人员结合业务需求进行配置（虽然通常是异步的）。</p> <p>你可能会好奇，什么时候我们需要使用同步的AJAX？就我个人经验而言，似乎很难找到相应的场景。Stack Overflow上有一个类似的问题，有兴趣的不妨点击<a href="https://stackoverflow.com/questions/4316488/when-is-it-appropriate-to-use-synchronous-ajax" target="_blank" rel="noopener noreferrer">查看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>最后我们再简单解释一下“同步”等待响应与“异步”等待响应的区别：“同步”意味着一旦请求发出，任何后续的JavaScript代码不会再执行，“异步”则是当请求发出后，后续的JavaScript代码会继续执行，当请求成功后，会调用相应的回调函数。</p> <hr> <h2 id="四、设置请求头"><a href="#四、设置请求头" class="header-anchor">#</a> 四、设置请求头</h2> <p>每个HTTP请求和响应都会带有相应的头部信息，包含一些与数据，收发者网络环境与状态等相关信息。XMLHttpRequest对象提供的<code>.setRequestHeader()</code>方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。</p> <p>默认情况下，当发送AJAX请求时，会附带以下头部信息：</p> <ul><li><code>Accept</code>：浏览器能够处理的内容类型；</li> <li><code>Accept-Charset</code>: 浏览器能够显示的字符集；</li> <li><code>Accept-Encoding</code>：浏览器能够处理的压缩编码；</li> <li><code>Accept-Language</code>：浏览器当前设置的语言；</li> <li><code>Connection</code>：浏览器与服务器之间连接的类型；</li> <li><code>Cookie</code>：当前页面设置的任何Cookie；</li> <li><code>Host</code>：发出请求的页面所在的域；</li> <li><code>Referer</code>：发出请求的页面URI；</li> <li><code>User-Agent</code>：浏览器的用户代理字符串；</li></ul> <p><strong>注意</strong>，部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：</p> <div class="language- extra-class"><pre class="language-text"><code>// 自定义请求头
xhr.setRequestHeader(&quot;myHeader&quot;, &quot;MyValue&quot;)
复制代码
</code></pre></div><hr> <h2 id="五、发送请求"><a href="#五、发送请求" class="header-anchor">#</a> 五、发送请求</h2> <p>到此为止，我们已经完全做好了发送请求的所有准备：利用<code>.open()</code>方法确定了请求方式，等待响应的方式和请求地址，甚至还通过<code>.setRequestHeader()</code>自定义了响应头，接下来就到了最激动人心的时刻：使用<code>.send()</code>方法，发送AJAX请求！</p> <div class="language- extra-class"><pre class="language-text"><code>// 发送AJAX请求！
const xhr = new XMLHttpRequest()
xhr.open(&quot;get&quot;, &quot;example.php&quot;, false)
xhr.setRequestHeader(&quot;myHeader&quot;, &quot;goodHeader&quot;)
xhr.send(null)
复制代码
</code></pre></div><p>呃，简单的有些令人尴尬不是吗？换个POST请求试试看：</p> <div class="language- extra-class"><pre class="language-text"><code>// 发送AJAX请求！
const xhr = new XMLHttpRequest()
xhr.open(&quot;post&quot;, &quot;example.php&quot;, false)
xhr.setRequestHeader(&quot;myHeader&quot;, &quot;bestHeader&quot;)
xhr.send(some_data)
复制代码
</code></pre></div><p>额..，总觉得还是差点什么？放轻松伙计，因为我们只是发出了请求，还没有<strong>处理响应</strong>，我们这就来看看它。</p> <hr> <h2 id="六、处理响应"><a href="#六、处理响应" class="header-anchor">#</a> 六、处理响应</h2> <p>让我们直接看看如何处理一个同步的GET请求响应：</p> <div class="language- extra-class"><pre class="language-text"><code>const xhr = new XMLHttpRequest()
xhr.open(&quot;get&quot;, &quot;example.php&quot;, false)
xhr.setRequestHeader(&quot;myHeader&quot;, &quot;goodHeader&quot;)
xhr.send(null)
// 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码
// 因此xhr.status的值一定不为默认值
if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
    alert(xhr.responseText)
} else {
    alert(&quot;Request was unsuccessful: &quot; + xhr.status)
}
复制代码
</code></pre></div><p>上面的代码不难理解，我们通过之前提到的xhr<code>.status</code>属性（如果你忘记了，它存储着响应的HTTP状态）判断请求是否成功，如果成功的话，我们将读取xhr<code>.responseText</code>属性中存储的返回值。但是，当我们的请求为异步时，问题就稍微变得复杂了，由于是异步的请求，在<code>xhr.send(null)</code>语句被执行后，JavaScript引擎会紧接着执行下面的判断语句，而这时由于尚未来得及响应，我们注定会得到一个默认的xhr.status值，因此，我们永远都不可能获取请求的资源了。</p> <p>如何解决这个问题？答案是通过为XMLHTTPRequest实例添加<code>onreadystatechange</code>事件处理程序（当然你也可以直接使用DOM2级规范规定的<code>.addEventListener()</code>方法，但是注意，IE8是不支持该方法的）。</p> <p>xhr实例的<code>readystatechange</code>事件会监听xhr<code>.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：</p> <ul><li><strong>0</strong>：未初始化 -- 尚未调用<code>.open()</code>方法；</li> <li><strong>1</strong>：启动 -- 已经调用<code>.open()</code>方法，但尚未调用<code>.send()</code>方法；</li> <li><strong>2</strong>：发送 -- 已经调用<code>.send()</code>方法，但尚未接收到响应；</li> <li><strong>3</strong>：接收 -- 已经接收到部分响应数据；</li> <li><strong>4</strong>：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了；</li></ul> <p>有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个异步的GET请求代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const xhr = new XMLHttpRequest()
xhr.onreadystatechange = () =&gt; {
    if (xhr.readystate == 4) {
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
            alert(xhr.responseText)
        } else {
            alert(&quot;Request was unsuccessful: &quot; + xhr.status)
        }
    }
}
xhr.open(&quot;get&quot;, &quot;example.php&quot;, true)
xhr.send(null)
复制代码
</code></pre></div><p><strong>注意</strong>：为了确保跨浏览器的兼容性，必须要在调用<code>.open()</code>方法之前指定事件处理程序，仔细想想也有道理，毕竟<code>.open()</code>方法的执行也包含在该事件处理程序的监听范围之内对吧？</p> <hr> <h2 id="七、取消异步请求"><a href="#七、取消异步请求" class="header-anchor">#</a> 七、取消异步请求</h2> <p>有时候，你可能需要在接收到响应之前取消异步请求，这时候，你需要调用<code>.abort()</code>方法。</p> <p>该方法会令XHR对象实例停止触发事件，并且不再允许访问任何和响应有关的对象属性。没了监控器，我们再也没法判断响应了不是吗？</p> <p>但是需要注意的是，当终止AJAX请求后，你需要手动对XHR对象实例进行解绑以释放内存空间。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-blog/assets/js/app.c767e7d4.js" defer></script><script src="/vuepress-blog/assets/js/2.2d10be97.js" defer></script><script src="/vuepress-blog/assets/js/16.474d60b7.js" defer></script>
  </body>
</html>
